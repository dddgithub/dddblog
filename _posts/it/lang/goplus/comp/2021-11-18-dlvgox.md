---
layout: post
title: 调试 gox 创建函数 AST 过程
date: 2021-11-18
Author: DDD
categories:
tags: [lang, goplus]
comments: false
toc: true
pinned: true
---
## gox 创建函数 AST

### ref

- go/types

```go
package types
import "go/types"
```

  package types declares the data types and implements the algorithms for
  type-checking of Go packages

- go/ast
- go/format

### dlv debug

**gox/package_test.go 中有一段  go 代码的构建例子，调试观察下大概的构建过程**

```go
package main

import fmt "fmt"

func main() {
    fmt.Println(fmt.Println())
}
```



**创建一个函数**

从  golang 语言的机制可以得知，一个源码文件需要有归属的 package ，意味着一段代码有所属的 package，构建一段代码大概就是需要在归属在某个 package 作用域下

所以，创建一个函数代码，也是在某个 package 下创建

```go
 139:	func TestPrintlnPrintln() {
   140:		pkg := newMainPackage(false) // package main
   141:		fmt := pkg.Import("fmt")
=> 142:		pkg.NewFunc(nil, "main", nil, nil, false).BodyStart(pkg). // package main 下创建 func main
   143:										Val(fmt.Ref("Println")).Val(fmt.Ref("Println")).Call(0).Call(1).EndStmt(). // 两个引用的函数入栈，然后按后进先出调用
   144:										End()
   145:		domTest(pkg, `package main
   146:
   147:	import fmt "fmt"
```

**Package 封装创建函数 AST 节点的方法**

可以看到构造代码的 AST 语法树，和 golang 的  go/types 有关联 

got/package 封装了从 package 为入口的各类代码构建方法， 比如新建一个 package ，在 package 中 import 引用的外部库， 在 package 中构建函数等，过程和写 go 代码的过程大概类似，比如

1、确定创建某个功能的 package 包

2、为 package 包创建第一个源码文件，在源码文件中定义和声明各种结构及类型，写相关函数，引用哪些外部包等

```go
118:	func (p *Package) NewFunc(recv *Param, name string, params, results *Tuple, variadic bool) *Func {
=> 119:		sig := types.NewSignature(recv, params, results, variadic)
   120:		fn, err := p.NewFuncWith(token.NoPos, name, sig, nil)
   121:		if err != nil {
   122:			panic(err)
   123:		}
   124:		return fn
(dlv) bt
0  0x00000000013107c7 in github.com/goplus/gox.(*Package).NewFunc
   at ./github.com/goplus/gox/func.go:119
1  0x00000000013324d8 in main.TestPrintlnPrintln
```

**types.NewSignature 是 golang 的机制， 具体看 go/types 对应的文档**

```go
=> 223:	func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature {
   224:		if variadic {
   225:			n := params.Len()
   226:			if n == 0 {
   227:				panic("types.NewSignature: variadic function must have at least one parameter")
   228:			}
(dlv) bt
0  0x000000000121198a in go/types.NewSignature
   at /usr/local/Cellar/go/1.17.2/libexec/src/go/types/type.go:223
```

**封装了创建一个函数的方法， 调用 go/types 中的 types.NewFunc 方法**

```go
> github.com/goplus/gox.(*Package).NewFuncWith() ./github.com/goplus/gox/func.go:137 (PC: 0x1310a0b)
   132:	}
   133:
   134:	// NewFuncWith func
   135:	func (p *Package) NewFuncWith(
   136:		pos token.Pos, name string, sig *types.Signature, recvTypePos func() token.Pos) (*Func, error) {
=> 137:		if name == "" {
   138:			panic("no func name")
   139:		}
   140:		cb := p.cb
   141:		fn := types.NewFunc(pos, p.Types, name, sig)
   142:		if recv := sig.Recv(); recv != nil { // add method to this type
(dlv) bt
0  0x0000000001310a0b in github.com/goplus/gox.(*Package).NewFuncWith
   at ./github.com/goplus/gox/func.go:137
1  0x0000000001310827 in github.com/goplus/gox.(*Package).NewFunc
   at ./github.com/goplus/gox/func.go:120
```

**调用 golang types.NewFunc**

```go
  303:	// NewFunc returns a new function with the given signature, representing
   304:	// the function's type.
=> 305:	func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func {
   306:		// don't store a (typed) nil signature
   307:		var typ Type
   308:		if sig != nil {
   309:			typ = sig
   310:		}
(dlv) bt
0  0x00000000011eb54a in go/types.NewFunc
   at /usr/local/Cellar/go/1.17.2/libexec/src/go/types/object.go:305
1  0x0000000001310a8e in github.com/goplus/gox.(*Package).NewFuncWith
   at ./github.com/goplus/gox/func.go:141
2  0x0000000001310827 in github.com/goplus/gox.(*Package).NewFunc
   at ./github.com/goplus/gox/func.go:120
```

**返回的 go/types.Func 结构**

```go
(dlv) p fn
*go/types.Func {
	object: go/types.object {
		parent: *go/types.Scope nil,  // 作用域
		pos: github.com/goplus/gox.closureNormal (0),
		pkg: *(*"go/types.Package")(0xc00005d4a0), // 归属的 package
		name: "main", // package name
		typ: go/types.Type(*go/types.Signature) ...,
		order_: 0,
		color_: black (1),
		scopePos_: github.com/goplus/gox.closureNormal (0),},
	hasPtrRecv: false,}
```

**从调用栈可以看到对 go/types 的调用**

```go
=>  42:	func (pkg *Package) Scope() *Scope { return pkg.scope }
    43:
    44:	// A package is complete if its scope contains (at least) all
    45:	// exported objects; otherwise it is incomplete.
    46:	func (pkg *Package) Complete() bool { return pkg.complete }
    47:
(dlv) bt
0  0x00000000011ee980 in go/types.(*Package).Scope
   at /usr/local/Cellar/go/1.17.2/libexec/src/go/types/package.go:42
1  0x0000000001311532 in github.com/goplus/gox.(*Package).NewFuncWith
```

**获取包的作用域, 并把函数对象加入对应的 package 作用域**

```go
> go/types.(*Scope).Insert() /usr/local/Cellar/go/1.17.2/libexec/src/go/types/scope.go:97 (PC: 0x11fe456)
    92:	// If s already contains an alternative object alt with
    93:	// the same name, Insert leaves s unchanged and returns alt.
    94:	// Otherwise it inserts obj, sets the object's parent scope
    95:	// if not already set, and returns nil.
    96:	func (s *Scope) Insert(obj Object) Object {
=>  97:		name := obj.Name()
    98:		if alt := s.elems[name]; alt != nil {
    99:			return alt
   100:		}
   101:		if s.elems == nil {
   102:			s.elems = make(map[string]Object)
(dlv) bt
0  0x00000000011fe456 in go/types.(*Scope).Insert
   at /usr/local/Cellar/go/1.17.2/libexec/src/go/types/scope.go:97
1  0x000000000131155e in github.com/goplus/gox.(*Package).NewFuncWith

=> 104:		s.elems[name] = obj
   105:		if obj.Parent() == nil {
   106:			obj.setParent(s)
   107:		}
   108:		return nil
   109:	}
(dlv) p name
"main"
(dlv) p obj
go/types.Object(*go/types.Func) *{ // 函数对象
	object: go/types.object {
		parent: *go/types.Scope nil,
		pos: github.com/goplus/gox.closureNormal (0),
		pkg: *(*"go/types.Package")(0xc00005d4a0),
		name: "main",
		typ: go/types.Type(*go/types.Signature) ...,
		order_: 0,
		color_: black (1),
		scopePos_: github.com/goplus/gox.closureNormal (0),},
	hasPtrRecv: false,}
```

**设置函数对象的所属作用域信息**

```go
 105:		if obj.Parent() == nil {
=> 106:			obj.setParent(s)
   107:		}
   108:		return nil
   109:	}
   110:
   111:	// squash merges s with its parent scope p by adding all
(dlv) p s
*go/types.Scope {
	parent: *go/types.Scope {
		parent: *go/types.Scope nil,
		children: []*go/types.Scope len: 0, cap: 0, nil,
		elems: map[string]go/types.Object [...],
		pos: github.com/goplus/gox.closureNormal (0),
		end: github.com/goplus/gox.closureNormal (0),
		comment: "universe",
		isFunc: false,},
	children: []*go/types.Scope len: 0, cap: 0, nil,
	elems: map[string]go/types.Object [
		"main": ...,
	],
	pos: github.com/goplus/gox.closureNormal (0),
	end: github.com/goplus/gox.closureNormal (0),
	comment: "package \"\"",
	isFunc: false,}
```

**为函数创建 AST 函数声明节点**

这部分是属于创建 AST 语法树， 参见 go/ast

相当于要构建的函数代码是一个 ast 的 FuncDecl 节点，即函数声明节点

```go
177:		decl := &ast.FuncDecl{}
=> 178:		idx := p.testingFile
   179:		p.files[idx].decls = append(p.files[idx].decls, decl)
   180:		return &Func{Func: fn, decl: decl}, nil // 把 go/types 和 go/ast 创建的两个结构封装关联
```

**开始构建函数体**

类似开始写函数内的代码语句

```go
> github.com/goplus/gox.(*Func).BodyStart() ./github.com/goplus/gox/func.go:76 (PC: 0x130fde2)
Warning: listing may not match stale executable
    71:		}
    72:	}
    73:
    74:	// BodyStart func
    75:	func (p *Func) BodyStart(pkg *Package) *CodeBuilder {
=>  76:		if debugInstr {
    77:			var recv string
    78:			tag := "NewFunc "
    79:			name := p.Name()
    80:			sig := p.Type().(*types.Signature)
    81:			if v := sig.Recv(); v != nil {
(dlv) bt
0  0x000000000130fde2 in github.com/goplus/gox.(*Func).BodyStart
   at ./github.com/goplus/gox/func.go:76
```

**可以看到具体构建代码语句的一些细活，gox/Package 委托给 gox/CodeBuilder**

代码按执行序列构建，遇到构建函数或调用时，会需要调用栈，构建代码的过程，类似逐行的执行代码过程

```go
> github.com/goplus/gox.(*CodeBuilder).startFuncBody() ./github.com/goplus/gox/codebuild.go:221 (PC: 0x1302d8f)
   216:	// Pkg returns the package instance.
   217:	func (p *CodeBuilder) Pkg() *Package {
   218:		return p.pkg
   219:	}
   220:
=> 221:	func (p *CodeBuilder) startFuncBody(fn *Func, old *funcBodyCtx) *CodeBuilder { // 函数体的开始
   222:		p.current.fn, old.fn = fn, p.current.fn // 可能有子函数，记录当前状态
   223:		p.startBlockStmt(fn, "func "+fn.Name(), &old.codeBlockCtx) // 块语句开始
   224:		scope := p.current.scope	// 涉及的作用域
   225:		sig := fn.Type().(*types.Signature) // 签名表示（非内置）函数或方法类型。接受者是在比较签名的标识时忽略。
   226:		insertParams(scope, sig.Params())	// 插入参数变量
(dlv) bt
0  0x0000000001302d8f in github.com/goplus/gox.(*CodeBuilder).startFuncBody
   at ./github.com/goplus/gox/codebuild.go:221
1  0x00000000013101a5 in github.com/goplus/gox.(*Func).BodyStart
   at ./github.com/goplus/gox/func.go:89
```
**开始构建一个语句块, 返回一个语句块构建过程的上下文**

```go
> github.com/goplus/gox.(*CodeBuilder).startBlockStmt() ./github.com/goplus/gox/codebuild.go:251 (PC: 0x130320f)
   246:		stmts, _ := p.endBlockStmt(&old.codeBlockCtx)
   247:		return stmts
   248:	}
   249:
   250:	// 一个语句块的开始
=> 251:	func (p *CodeBuilder) startBlockStmt(current codeBlock, comment string, old *codeBlockCtx) *CodeBuilder {
   252:		scope := types.NewScope(p.current.scope, token.NoPos, token.NoPos, comment)
   253:		p.current.codeBlockCtx, *old = codeBlockCtx{current, scope, p.stk.Len(), nil, nil, 0}, p.current.codeBlockCtx
   254:		return p
   255:	}
   256:
(dlv) bt
0  0x000000000130320f in github.com/goplus/gox.(*CodeBuilder).startBlockStmt
   at ./github.com/goplus/gox/codebuild.go:251
1  0x0000000001302ece in github.com/goplus/gox.(*CodeBuilder).startFuncBody
   at ./github.com/goplus/gox/codebuild.go:223
2  0x00000000013101a5 in github.com/goplus/gox.(*Func).BodyStart
   at ./github.com/goplus/gox/func.go:89
```
**插入参数**

参数的声明是有作用域的

```go
> github.com/goplus/gox.insertParams() ./github.com/goplus/gox/codebuild.go:235 (PC: 0x1303022)
   230:		}
   231:		return p
   232:	}
   233:
   234:	func insertParams(scope *types.Scope, params *types.Tuple) {
=> 235:		for i, n := 0, params.Len(); i < n; i++ {  // 遍历参数
   236:			v := params.At(i)
   237:			if name := v.Name(); name != "" {
   238:				scope.Insert(v) // 参数在哪些作用域范围内有效
   239:			}
   240:		}
(dlv) bt
0  0x0000000001303022 in github.com/goplus/gox.insertParams
   at ./github.com/goplus/gox/codebuild.go:235
1  0x0000000001302f45 in github.com/goplus/gox.(*CodeBuilder).startFuncBody
   at ./github.com/goplus/gox/codebuild.go:226
2  0x00000000013101a5 in github.com/goplus/gox.(*Func).BodyStart
   at ./github.com/goplus/gox/func.go:89
```

**引用一个包的方法**

```go
> github.com/goplus/gox.(*PkgRef).Ref() ./github.com/goplus/gox/import.go:102 (PC: 0x131266f)
    97:		}
    98:	}
    99:
   100:	// Ref returns the object in this package with the given name if such an
   101:	// object exists; otherwise it panics.
=> 102:	func (p *PkgRef) Ref(name string) Ref {
   103:		if o := p.TryRef(name); o != nil {
   104:			return o
   105:		}
   106:		panic(p.Types.Path() + "." + name + " not found")
   107:	}
(dlv) bt
0  0x000000000131266f in github.com/goplus/gox.(*PkgRef).Ref
   at ./github.com/goplus/gox/import.go:102


> github.com/goplus/gox.(*PkgRef).TryRef() ./github.com/goplus/gox/import.go:111 (PC: 0x13127c6)
   106:		panic(p.Types.Path() + "." + name + " not found")
   107:	}
   108:
   109:	// TryRef returns the object in this package with the given name if such an
   110:	// object exists; otherwise it returns nil.
=> 111:	func (p *PkgRef) TryRef(name string) Ref {
   112:		p.EnsureImported()
   113:		return p.Types.Scope().Lookup(name)
   114:	}
   115:
   116:	// MarkForceUsed marks this package is force-used.
(dlv) bt
0  0x00000000013127c6 in github.com/goplus/gox.(*PkgRef).TryRef
   at ./github.com/goplus/gox/import.go:111
1  0x00000000013126c5 in github.com/goplus/gox.(*PkgRef).Ref
   at ./github.com/goplus/gox/import.go:103
```

```go
> github.com/goplus/gox.(*file).endImport() ./github.com/goplus/gox/package.go:181 (PC: 0x1316d80)
   176:		}
   177:		return pkgImport
   178:	}
   179:
   180:	func (p *file) endImport(this *Package, testingFile bool) {
=> 181:		pkgPaths := p.delayPkgPaths
   182:		if len(pkgPaths) == 0 {
   183:			return
   184:		}
   185:		if debugImport {
   186:			log.Println("==> LoadPkgs", pkgPaths, testingFile)
(dlv) bt
0  0x0000000001316d80 in github.com/goplus/gox.(*file).endImport
   at ./github.com/goplus/gox/package.go:181
1  0x00000000013128df in github.com/goplus/gox.(*PkgRef).EnsureImported
   at ./github.com/goplus/gox/import.go:124
2  0x00000000013127f3 in github.com/goplus/gox.(*PkgRef).TryRef
   at ./github.com/goplus/gox/import.go:112
3  0x00000000013126c5 in github.com/goplus/gox.(*PkgRef).Ref
   at ./github.com/goplus/gox/import.go:103
```
**加载包**
```go
> github.com/goplus/gox.(*file).endImport() ./github.com/goplus/gox/package.go:191 (PC: 0x1316fed)
   186:			log.Println("==> LoadPkgs", pkgPaths, testingFile)
   187:		}
   188:		if n := this.loadPkgs(this, p.importPkgs, pkgPaths...); n > 0 {
   189:			log.Panicf("total %d errors\n", n) // TODO: error message
   190:		}
=> 191:		p.delayPkgPaths = pkgPaths[:0]
   192:	}
```

**在作用域中查询引用的方法**

```go
111:	func (p *PkgRef) TryRef(name string) Ref {
   112:		p.EnsureImported()
=> 113:		return p.Types.Scope().Lookup(name)
   114:	}
   115:
   116:	// MarkForceUsed marks this package is force-used.
   117:	func (p *PkgRef) MarkForceUsed() {
   118:		p.isForceUsed = true
(dlv) p name
"Println"


> go/types.(*Scope).Lookup() /usr/local/Cellar/go/1.17.2/libexec/src/go/types/scope.go:69 (PC: 0x11fe209)
    64:	func (s *Scope) Child(i int) *Scope { return s.children[i] }
    65:
    66:	// Lookup returns the object in scope s with the given name if such an
    67:	// object exists; otherwise the result is nil.
    68:	func (s *Scope) Lookup(name string) Object {
=>  69:		return s.elems[name]
    70:	}
    71:
    72:	// LookupParent follows the parent chain of scopes starting with s until
    73:	// it finds a scope where Lookup(name) returns a non-nil object, and then
    74:	// returns that scope and object. If a valid position pos is provided,
(dlv) bt
0  0x00000000011fe209 in go/types.(*Scope).Lookup
   at /usr/local/Cellar/go/1.17.2/libexec/src/go/types/scope.go:69
1  0x000000000131281c in github.com/goplus/gox.(*PkgRef).TryRef
   at ./github.com/goplus/gox/import.go:113
2  0x00000000013126c5 in github.com/goplus/gox.(*PkgRef).Ref
   at ./github.com/goplus/gox/import.go:103
3  0x000000
```
**返回引用的方法函数对象**

被引用的 package 的方法函数， 在 package 加载时，其所属的各种 func 都被加载创建成了对应的函数对象 

```go
 100:	// Ref returns the object in this package with the given name if such an
   101:	// object exists; otherwise it panics.
   102:	func (p *PkgRef) Ref(name string) Ref {
   103:		if o := p.TryRef(name); o != nil {
=> 104:			return o
   105:		}
   106:		panic(p.Types.Path() + "." + name + " not found")
   107:	}
   108:
   109:	// TryRef returns the object in this package with the given name if such an
(dlv) p o
go/types.Object(*go/types.Func) *{
	object: go/types.object {
		parent: *(*"go/types.Scope")(0xc0081e4d20),
		pos: 3502577,
		pkg: *(*"go/types.Package")(0xc0081e4d70),
		name: "Println",
		typ: go/types.Type(*go/types.Signature) ...,
		order_: 69,
		color_: black (1),
		scopePos_: github.com/goplus/gox.closureNormal (0),},
	hasPtrRecv: false,}
```

```go
 1260:	// Val func
=>1261:	func (p *CodeBuilder) Val(v interface{}, src ...ast.Node) *CodeBuilder { // 调用函数
  1262:		if debugInstr {
  1263:			if o, ok := v.(types.Object); ok {
  1264:				log.Println("Val", o.Name(), o.Type())
  1265:			} else {
  1266:				log.Println("Val", v, reflect.TypeOf(v))
(dlv) bt
0  0x00000000013072b2 in github.com/goplus/gox.(*CodeBuilder).Val
   at ./github.com/goplus/gox/codebuild.go:1261
```

```go
> github.com/goplus/gox.(*CodeBuilder).Val() ./github.com/goplus/gox/codebuild.go:1264 (PC: 0x1307385)
  1259:
  1260:	// Val func
  1261:	func (p *CodeBuilder) Val(v interface{}, src ...ast.Node) *CodeBuilder { // 调用函数
  1262:		if debugInstr {
  1263:			if o, ok := v.(types.Object); ok {
=>1264:				log.Println("Val", o.Name(), o.Type())
  1265:			} else {
  1266:				log.Println("Val", v, reflect.TypeOf(v))
  1267:			}
  1268:		}
  1269:		fn := p.current.fn
(dlv) p o
go/types.Object(*go/types.Func) *{
	object: go/types.object {
		parent: *(*"go/types.Scope")(0xc0081e4d20),
		pos: 3502577,
		pkg: *(*"go/types.Package")(0xc0081e4d70),
		name: "Println",
		typ: go/types.Type(*go/types.Signature) ...,
		order_: 69,
		color_: black (1),
		scopePos_: github.com/goplus/gox.closureNormal (0),},
	hasPtrRecv: false,}


> github.com/goplus/gox.(*CodeBuilder).Val() ./github.com/goplus/gox/codebuild.go:1269 (PC: 0x130766e)
  1264:				log.Println("Val", o.Name(), o.Type())
  1265:			} else {
  1266:				log.Println("Val", v, reflect.TypeOf(v))
  1267:			}
  1268:		}
=>1269:		fn := p.current.fn
  1270:		if fn != nil && fn.isInline() { // is in an inline call
  1271:			if param, ok := v.(*types.Var); ok {
  1272:				key := closureParamInst{fn, param}
  1273:				if arg, ok := p.paramInsts[key]; ok { // replace param with arg
  1274:					v = arg
(dlv) p p.current.fn
*github.com/goplus/gox.Func {
	Func: *go/types.Func {
		object: (*"go/types.object")(0xc005ac36d0),
		hasPtrRecv: false,},
	decl: *go/ast.FuncDecl {
		Doc: *go/ast.CommentGroup nil,
		Recv: *go/ast.FieldList nil,
		Name: *go/ast.Ident nil,
		Type: *go/ast.FuncType nil,
		Body: *go/ast.BlockStmt nil,},
	old: github.com/goplus/gox.funcBodyCtx {
		codeBlockCtx: (*"github.com/goplus/gox.codeBlockCtx")(0xc00010a010),
		fn: *github.com/goplus/gox.Func nil,
		labels: map[string]*github.com/goplus/gox.Label nil,},}
```

**构建函数调用执行动作**

```go
> github.com/goplus/gox.(*CodeBuilder).Call() ./github.com/goplus/gox/codebuild.go:409 (PC: 0x130432a)
   404:		}
   405:		return p
   406:	}
   407:
   408:	// Call func
=> 409:	func (p *CodeBuilder) Call(n int, ellipsis ...bool) *CodeBuilder { // 调用函数
   410:		return p.CallWith(n, ellipsis != nil && ellipsis[0])
   411:	}
   412:
   413:	// CallWith func
   414:	func (p *CodeBuilder) CallWith(n int, ellipsis bool, src ...ast.Node) *CodeBuilder { // 调用函数
(dlv) bt
0  0x000000000130432a in github.com/goplus/gox.(*CodeBuilder).Call
   at ./github.com/goplus/gox/codebuild.go:409
1  0x00000000013325f9 in main.TestPrintlnPrintln
   at ./testpkg.go:143
2  0x00000000013326d0 in main.main
   at ./testpkg.go:159
3  0x0000000001037c93 in runtime.main
   at /usr/local/Cellar/go/1.17.2/libexec/src/runtime/proc.go:255
4  0x0000000001065781 in runtime.goexit
   at /usr/local/Cellar/go/1.17.2/libexec/src/runtime/asm_amd64.s:1581
```

**构建函数调用执行动作**

```go
> github.com/goplus/gox.(*CodeBuilder).CallWith() ./github.com/goplus/gox/codebuild.go:416 (PC: 0x13044ac)
   411:	}
   412:
   413:	// CallWith func
   414:	func (p *CodeBuilder) CallWith(n int, ellipsis bool, src ...ast.Node) *CodeBuilder { // 调用函数
   415:		fn := p.stk.Get(-(n + 1)) // n 栈的位置中的应用的函数
=> 416:		if t, ok := fn.Type.(*btiMethodType); ok {
   417:			n++ // 从栈顶往下找
   418:			fn.Type = t.Type
   419:			fn = p.stk.Get(-(n + 1))
   420:			if t.eargs != nil { // 输入的参数
   421:				for _, arg := range t.eargs {
(dlv) bt
0  0x00000000013044ac in github.com/goplus/gox.(*CodeBuilder).CallWith
   at ./github.com/goplus/gox/codebuild.go:416
1  0x00000000013043a5 in github.com/goplus/gox.(*CodeBuilder).Call
   at ./github.com/goplus/gox/codebuild.go:410
2  0x00000000013325f9 in main.TestPrintlnPrintln
   at ./testpkg.go:143
3  0x00000000013326d0 in main.main
   at ./testpkg.go:159
4  0x0000000001037c93 in runtime.main
   at /usr/local/Cellar/go/1.17.2/libexec/src/runtime/proc.go:255
5  0x0000000001065781 in runtime.goexit
   at /usr/local/Cellar/go/1.17.2/libexec/src/runtime/asm_amd64.s:1581
```

**从栈顶把 func 及相关参数信息提取出来**

```go
> github.com/goplus/gox.(*CodeBuilder).CallWith() ./github.com/goplus/gox/codebuild.go:416 (PC: 0x13044ac)
   411:	}
   412:
   413:	// CallWith func
   414:	func (p *CodeBuilder) CallWith(n int, ellipsis bool, src ...ast.Node) *CodeBuilder { // 调用函数
   415:		fn := p.stk.Get(-(n + 1)) // n 栈的位置中的应用的函数
=> 416:		if t, ok := fn.Type.(*btiMethodType); ok {
   417:			n++ // 从栈顶往下找
   418:			fn.Type = t.Type
   419:			fn = p.stk.Get(-(n + 1))
   420:			if t.eargs != nil { // 输入的参数
   421:				for _, arg := range t.eargs {
(dlv) p fn
*github.com/goplus/gox/internal.Elem {
	Val: go/ast.Expr(*go/ast.SelectorExpr) *{
		X: go/ast.Expr(*go/ast.Ident) ...,
		Sel: *(*"go/ast.Ident")(0xc009eef120),},
	Type: go/types.Type(*go/types.Signature) *{
		rparams: []*go/types.TypeName len: 0, cap: 0, nil,
		tparams: []*go/types.TypeName len: 0, cap: 0, nil,
		scope: *(*"go/types.Scope")(0xc00848b5e0),
		recv: *go/types.Var nil,
		params: *(*"go/types.Tuple")(0xc0084e38d8),
		results: *(*"go/types.Tuple")(0xc0084e38f0),
		variadic: true,},
	CVal: go/constant.Value nil,
	Src: go/ast.Node nil,}
```

**执行调用函数**

```go
 420:	func toFuncCall(pkg *Package, fn *internal.Elem, args []*internal.Elem, flags InstrFlags) *internal.Elem {
=> 421:		ret, err := matchFuncCall(pkg, fn, args, flags)
   422:		if err != nil {
   423:			panic(err)
   424:		}
   425:		return ret
   426:	}
(dlv) bt
0  0x00000000012e815f in github.com/goplus/gox.toFuncCall
   at ./github.com/goplus/gox/ast.go:421
1  0x000000000130481f in github.com/goplus/gox.(*CodeBuilder).CallWith
   at ./github.com/goplus/gox/codebuild.go:437
2  0x00000000013043a5 in github.com/goplus/gox.(*CodeBuilder).Call
   at ./github.com/goplus/gox/codebuild.go:410
3  0x00000000013325f9 in main.TestPrintlnPrintln
   at ./testpkg.go:143
4  0x00000000013326d0 in main.main
   at ./testpkg.go:159
5  0x0000000001037c93 in runtime.main
   at /usr/local/Cellar/go/1.17.2/libexec/src/runtime/proc.go:255
6  0x0000000001065781 in runtime.goexit
   at /usr/local/Cellar/go/1.17.2/libexec/src/runtime/asm_amd64.s:1581
(dlv) s
> github.com/goplus/gox.matchFuncCall() ./github.com/goplus/gox/ast.go:535 (PC: 0x12e8c12)
   530:			return 1
   531:		}
   532:		return 0
   533:	}
   534:
=> 535:	func matchFuncCall(pkg *Package, fn *internal.Elem, args []*internal.Elem, flags InstrFlags) (ret *internal.Elem, err error) {
   536:		fnType := fn.Type
   537:		if debugMatch {
   538:			var funcs []types.Object
   539:			var ok bool
   540:			if t, ok1 := fnType.(*types.Signature); ok1 {
(dlv) n
> github.com/goplus/gox.matchFuncCall() ./github.com/goplus/gox/ast.go:536 (PC: 0x12e8c6e)
   531:		}
   532:		return 0
   533:	}
   534:
   535:	func matchFuncCall(pkg *Package, fn *internal.Elem, args []*internal.Elem, flags InstrFlags) (ret *internal.Elem, err error) {
=> 536:		fnType := fn.Type
   537:		if debugMatch {
   538:			var funcs []types.Object
   539:			var ok bool
   540:			if t, ok1 := fnType.(*types.Signature); ok1 {
   541:				funcs, ok = CheckOverloadMethod(t)
(dlv) bt
0  0x00000000012e8c6e in github.com/goplus/gox.matchFuncCall
   at ./github.com/goplus/gox/ast.go:536
1  0x00000000012e81a5 in github.com/goplus/gox.toFuncCall
   at ./github.com/goplus/gox/ast.go:421
2  0x000000000130481f in github.com/goplus/gox.(*CodeBuilder).CallWith
   at ./github.com/goplus/gox/codebuild.go:437
3  0x00000000013043a5 in github.com/goplus/gox.(*CodeBuilder).Call
   at ./github.com/goplus/gox/codebuild.go:410
4  0x00000000013325f9 in main.TestPrintlnPrintln
   at ./testpkg.go:143
5  0x00000000013326d0 in main.main
   at ./testpkg.go:159
6  0x0000000001037c93 in runtime.main
   at /usr/local/Cellar/go/1.17.2/libexec/src/runtime/proc.go:255
7  0x0000000001065781 in runtime.goexit
   at /usr/local/Cellar/go/1.17.2/libexec/src/runtime/asm_amd64.s:1581
(dlv)
```

```go
> github.com/goplus/gox.CheckOverloadMethod() ./github.com/goplus/gox/func.go:214 (PC: 0x1311d0a)
Warning: listing may not match stale executable
   209:		ofn := types.NewFunc(pos, pkg, name, sig)
   210:		typ.AddMethod(ofn)
   211:		return ofn
   212:	}
   213:
=> 214:	func CheckOverloadMethod(sig *types.Signature) (funcs []types.Object, ok bool) {
   215:		if recv := sig.Recv(); recv != nil {
   216:			if oft, ok := recv.Type().(*overloadFuncType); ok {
   217:				return oft.funcs, true
   218:			}
   219:		}
(dlv) bt
0  0x0000000001311d0a in github.com/goplus/gox.CheckOverloadMethod
   at ./github.com/goplus/gox/func.go:214
1  0x00000000012e9327 in github.com/goplus/gox.matchFuncCall
   at ./github.com/goplus/gox/ast.go:555
2  0x00000000012e81a5 in github.com/goplus/gox.toFuncCall
   at ./github.com/goplus/gox/ast.go:421
3  0x000000000130481f in github.com/goplus/gox.(*CodeBuilder).CallWith
   at ./github.com/goplus/gox/codebuild.go:437
4  0x00000000013043a5 in github.com/goplus/gox.(*CodeBuilder).Call
   at ./github.com/goplus/gox/codebuild.go:410
```

```go
> github.com/goplus/gox.toRetType() ./github.com/goplus/gox/ast.go:740 (PC: 0x12ec24a)
   735:			}, true
   736:		}
   737:		return nil, false
   738:	}
   739:
=> 740:	func toRetType(t *types.Tuple, it *instantiated) types.Type {
   741:		if t == nil {
   742:			return nil
   743:		} else if t.Len() == 1 {
   744:			return it.normalize(t.At(0).Type())
   745:		}
(dlv) bt
0  0x00000000012ec24a in github.com/goplus/gox.toRetType
   at ./github.com/goplus/gox/ast.go:740
1  0x00000000012e9c05 in github.com/goplus/gox.matchFuncCall
   at ./github.com/goplus/gox/ast.go:649
2  0x00000000012e81a5 in github.com/goplus/gox.toFuncCall
   at ./github.com/goplus/gox/ast.go:421
3  0x000000000130481f in github.com/goplus/gox.(*CodeBuilder).CallWith
   at ./github.com/goplus/gox/codebuild.go:437
4  0x00000000013043a5 in github.com/goplus/gox.(*CodeBuilder).Call
   at ./github.com/goplus/gox/codebuild.go:410
```

```go
> github.com/goplus/gox.(*instantiated).normalizeTuple() ./github.com/goplus/gox/template.go:458 (PC: 0x13225aa)
   453:			t, _ = toNormalize(p.tparams, t)
   454:		}
   455:		return t
   456:	}
   457:
=> 458:	func (p *instantiated) normalizeTuple(t *types.Tuple) *types.Tuple {
   459:		if p != nil && p.results {
   460:			t, _ = toNormalizeTuple(p.tparams, t)
   461:		}
   462:		return t
   463:	}
(dlv) bt
0  0x00000000013225aa in github.com/goplus/gox.(*instantiated).normalizeTuple
   at ./github.com/goplus/gox/template.go:458
1  0x00000000012ec30e in github.com/goplus/gox.toRetType
   at ./github.com/goplus/gox/ast.go:746
2  0x00000000012e9c05 in github.com/goplus/gox.matchFuncCall
   at ./github.com/goplus/gox/ast.go:649
3  0x00000000012e81a5 in github.com/goplus/gox.toFuncCall
   at ./github.com/goplus/gox/ast.go:421
4  0x000000000130481f in github.com/goplus/gox.(*CodeBuilder).CallWith
   at ./github.com/goplus/gox/codebuild.go:437
5  0x00000000013043a5 in github.com/goplus/gox.(*CodeBuilder).Call
   at ./github.com/goplus/gox/codebuild.go:410
```

```go
> github.com/goplus/gox.getParam1st() ./github.com/goplus/gox/ast.go:528 (PC: 0x12e8b86)
   523:			return sig.Recv()
   524:		}
   525:		return sig.Params().At(i)
   526:	}
   527:
=> 528:	func getParam1st(sig *types.Signature) int {
   529:		if sig.Recv() != nil {
   530:			return 1
   531:		}
   532:		return 0
   533:	}
(dlv) bt
0  0x00000000012e8b86 in github.com/goplus/gox.getParam1st
   at ./github.com/goplus/gox/ast.go:528
1  0x00000000012ea1e5 in github.com/goplus/gox.matchFuncCall
   at ./github.com/goplus/gox/ast.go:665
```

**看到创建调用表达式 AST 节点了， ast.CallExpr**

```go
> github.com/goplus/gox.matchFuncCall() ./github.com/goplus/gox/ast.go:674 (PC: 0x12ea25e)
   669:				valArgs[i-recv] = args[i].Val
   670:			}
   671:		}
   672:		return &internal.Elem{
   673:			Type: tyRet, CVal: cval,
=> 674:			Val: &ast.CallExpr{Fun: fn.Val, Args: valArgs, Ellipsis: flags & InstrFlagEllipsis},
   675:		}, nil
   676:	}
   677:
   678:	func isPointer(typ types.Type) bool {
   679:		_, ok := typ.(*types.Pointer)
(dlv) bt
0  0x00000000012ea25e in github.com/goplus/gox.matchFuncCall
   at ./github.com/goplus/gox/ast.go:674
1  0x00000000012e81a5 in github.com/goplus/gox.toFuncCall
   at ./github.com/goplus/gox/ast.go:421
```

```go
> github.com/goplus/gox.matchFuncCall() ./github.com/goplus/gox/ast.go:674 (PC: 0x12ea25e)
   669:				valArgs[i-recv] = args[i].Val
   670:			}
   671:		}
   672:		return &internal.Elem{
   673:			Type: tyRet, CVal: cval,
=> 674:			Val: &ast.CallExpr{Fun: fn.Val, Args: valArgs, Ellipsis: flags & InstrFlagEllipsis},
   675:		}, nil
   676:	}
   677:
   678:	func isPointer(typ types.Type) bool {
   679:		_, ok := typ.(*types.Pointer)
(dlv) bt
0  0x00000000012ea25e in github.com/goplus/gox.matchFuncCall
   at ./github.com/goplus/gox/ast.go:674
1  0x00000000012e81a5 in github.com/goplus/gox.toFuncCall
   at ./github.com/goplus/gox/ast.go:421
```

```go
dlv) p fn
*github.com/goplus/gox/internal.Elem {
	Val: go/ast.Expr(*go/ast.SelectorExpr) *{
		X: go/ast.Expr(*go/ast.Ident) ...,
		Sel: *(*"go/ast.Ident")(0xc009eef120),},
	Type: go/types.Type(*go/types.Signature) *{
		rparams: []*go/types.TypeName len: 0, cap: 0, nil,
		tparams: []*go/types.TypeName len: 0, cap: 0, nil,
		scope: *(*"go/types.Scope")(0xc00848b5e0),
		recv: *go/types.Var nil,
		params: *(*"go/types.Tuple")(0xc0084e38d8),
		results: *(*"go/types.Tuple")(0xc0084e38f0),
		variadic: true,},
	CVal: go/constant.Value nil,
	Src: go/ast.Node nil,}
(dlv) p fn.Val
go/ast.Expr(*go/ast.SelectorExpr) *{ // 类似 a.b 这样的表达式， fmt.Println
	X: go/ast.Expr(*go/ast.Ident) *{
		NamePos: github.com/goplus/gox.closureNormal (0),
		Name: "fmt",
		Obj: *go/ast.Object nil,},
	Sel: *go/ast.Ident {
		NamePos: github.com/goplus/gox.closureNormal (0),
		Name: "Println",
		Obj: *go/ast.Object nil,},}
```

```go
 420:	func toFuncCall(pkg *Package, fn *internal.Elem, args []*internal.Elem, flags InstrFlags) *internal.Elem {
   421:		ret, err := matchFuncCall(pkg, fn, args, flags)
=> 422:		if err != nil {
   423:			panic(err)
   424:		}
   425:		return ret
   426:	}
   427:
(dlv) p ret
*github.com/goplus/gox/internal.Elem {
	Val: go/ast.Expr(*go/ast.CallExpr) *{
		Fun: go/ast.Expr(*go/ast.SelectorExpr) ...,
		Lparen: github.com/goplus/gox.closureNormal (0),
		Args: []go/ast.Expr len: 0, cap: 0, nil,
		Ellipsis: github.com/goplus/gox.closureNormal (0),
		Rparen: github.com/goplus/gox.closureNormal (0),},
	Type: go/types.Type(*go/types.Tuple) *{
		vars: []*go/types.Var len: 2, cap: 2, [
			*(*"go/types.Var")(0xc00848b6d0),
			*(*"go/types.Var")(0xc00848b720),
		],},
	CVal: go/constant.Value nil,
	Src: go/ast.Node nil,}
```
**函数执行调用的返回值入栈**

```go
(dlv) n
> github.com/goplus/gox.(*CodeBuilder).CallWith() ./github.com/goplus/gox/codebuild.go:439 (PC: 0x1304856)
   434:		}
   435:		s := getSrc(src)
   436:		fn.Src = s
   437:		ret := toFuncCall(p.pkg, fn, args, flags) // 去调用函数
   438:		ret.Src = s
=> 439:		p.stk.Ret(n+1, ret) // 入栈
   440:		return p
   441:	}
   442:
```

**语句结束**

一段代码语句构建或执行完毕后，构建一个对应的 AST 节点， ast./ExprStmt

```go
> github.com/goplus/gox.(*CodeBuilder).EndStmt() ./github.com/goplus/gox/codebuild.go:2264 (PC: 0x130c7c6)
  2259:		p.stk.SetLen(p.current.base)
  2260:	}
  2261:
  2262:	// EndStmt func
  2263:	func (p *CodeBuilder) EndStmt() *CodeBuilder {
=>2264:		n := p.stk.Len() - p.current.base
  2265:		if n > 0 {
  2266:			if n != 1 {
  2267:				panic("syntax error: unexpected newline, expecting := or = or comma")
  2268:			}
  2269:			stmt := &ast.ExprStmt{X: p.stk.Pop().Val}
(dlv) bt
0  0x000000000130c7c6 in github.com/goplus/gox.(*CodeBuilder).EndStmt
   at ./github.com/goplus/gox/codebuild.go:2264
```
**生成一个 AST 表达式语句节点**

```go
> github.com/goplus/gox.(*CodeBuilder).EndStmt() ./github.com/goplus/gox/codebuild.go:2270 (PC: 0x130c868)
  2265:		if n > 0 {
  2266:			if n != 1 {
  2267:				panic("syntax error: unexpected newline, expecting := or = or comma")
  2268:			}
  2269:			stmt := &ast.ExprStmt{X: p.stk.Pop().Val}
=>2270:			p.emitStmt(stmt)
  2271:		}
  2272:		return p
  2273:	}
  2274:
  2275:	// End func
(dlv) p stmt
*go/ast.ExprStmt {
	X: go/ast.Expr(*go/ast.CallExpr) *{
		Fun: go/ast.Expr(*go/ast.SelectorExpr) ...,
		Lparen: github.com/goplus/gox.closureNormal (0),
		Args: []go/ast.Expr len: 1, cap: 1, [
			...,
		],
		Ellipsis: github.com/goplus/gox.closureNormal (0),
		Rparen: github.com/goplus/gox.closureNormal (0),},}
```

**宣告一个语句表达式生成**

```go
> github.com/goplus/gox.(*CodeBuilder).emitStmt() ./github.com/goplus/gox/codebuild.go:302 (PC: 0x130392a)
   297:			copy(stmts[idx:], stmts[idx+1:])
   298:			stmts[n] = stmt
   299:		}
   300:	}
   301:
=> 302:	func (p *CodeBuilder) emitStmt(stmt ast.Stmt) {
   303:		if p.comments != nil {
   304:			p.pkg.setStmtComments(stmt, p.comments) // 设置语句的注释
   305:			if p.commentOnce {
   306:				p.comments = nil
   307:			}
(dlv) bt
0  0x000000000130392a in github.com/goplus/gox.(*CodeBuilder).emitStmt
   at ./github.com/goplus/gox/codebuild.go:302
1  0x000000000130c885 in github.com/goplus/gox.(*CodeBuilder).EndStmt
   at ./github.com/goplus/gox/codebuild.go:2270
```

**结束代码构建**

```go
> github.com/goplus/gox.(*CodeBuilder).End() ./github.com/goplus/gox/codebuild.go:2277 (PC: 0x130c917)
  2272:		return p
  2273:	}
  2274:
  2275:	// End func
  2276:	func (p *CodeBuilder) End() *CodeBuilder {
=>2277:		if debugInstr {
  2278:			typ := reflect.TypeOf(p.current.codeBlock)
  2279:			if typ.Kind() == reflect.Ptr {
  2280:				typ = typ.Elem()
  2281:			}
  2282:			name := strings.TrimSuffix(strings.Title(typ.Name()), "Stmt")
(dlv) bt
0  0x000000000130c917 in github.com/goplus/gox.(*CodeBuilder).End
   at ./github.com/goplus/gox/codebuild.go:2277
```

** **

```go
> github.com/goplus/gox.(*CodeBuilder).End() ./github.com/goplus/gox/codebuild.go:2283 (PC: 0x130ca10)
  2278:			typ := reflect.TypeOf(p.current.codeBlock)
  2279:			if typ.Kind() == reflect.Ptr {
  2280:				typ = typ.Elem()
  2281:			}
  2282:			name := strings.TrimSuffix(strings.Title(typ.Name()), "Stmt")
=>2283:			log.Println("End //", name)
  2284:			if p.stk.Len() > p.current.base {
  2285:				panic("forget to call EndStmt()?")
  2286:			}
  2287:		}
  2288:		p.current.End(p)
(dlv) p name
"Func"
```

```go
> github.com/goplus/gox.(*Func).End() ./github.com/goplus/gox/func.go:93 (PC: 0x1310212)
Warning: listing may not match stale executable
    88:		}
    89:		return pkg.cb.startFuncBody(p, &p.old)
    90:	}
    91:
    92:	// End is for internal use.
=>  93:	func (p *Func) End(cb *CodeBuilder) {
    94:		if p.isInline() {
    95:			p.inlineClosureEnd(cb)
    96:			return
    97:		}
    98:		pkg := cb.pkg
(dlv) bt
0  0x0000000001310212 in github.com/goplus/gox.(*Func).End
   at ./github.com/goplus/gox/func.go:93
1  0x000000000130cb26 in github.com/goplus/gox.(*CodeBuilder).End
   at ./github.com/goplus/gox/codebuild.go:2288
```

**在 AST 中，一个函数的 body 是一个 ast.BlockStmt 节点**

```go
> github.com/goplus/gox.(*Func).End() ./github.com/goplus/gox/func.go:100 (PC: 0x13103af)
Warning: listing may not match stale executable
    95:			p.inlineClosureEnd(cb)
    96:			return
    97:		}
    98:		pkg := cb.pkg
    99:		body := &ast.BlockStmt{List: cb.endFuncBody(p.old)}
=> 100:		t, _ := toNormalizeSignature(nil, p.Type().(*types.Signature))
   101:		if fn := p.decl; fn == nil { // is closure
   102:			expr := &ast.FuncLit{Type: toFuncType(pkg, t), Body: body}
   103:			cb.stk.Push(&internal.Elem{Val: expr, Type: t})
   104:		} else {
   105:			fn.Name, fn.Type, fn.Body = ident(p.Name()), toFuncType(pkg, t), body
(dlv) p body
*go/ast.BlockStmt {
	Lbrace: github.com/goplus/gox.closureNormal (0),
	List: []go/ast.Stmt len: 1, cap: 1, [ // 一个函数的 body 包含若干的 ast.Stmt
		...,
	],
	Rbrace: github.com/goplus/gox.closureNormal (0),}
```

**回调调当前处理上下文对应的 End 方法**

```go
> github.com/goplus/gox.(*CodeBuilder).End() ./github.com/goplus/gox/codebuild.go:2289 (PC: 0x130cb26)
Values returned:

  2284:			if p.stk.Len() > p.current.base {
  2285:				panic("forget to call EndStmt()?")
  2286:			}
  2287:		}
  2288:		p.current.End(p)
=>2289:		return p
  2290:	}
  2291:
  2292:	func (p *CodeBuilder) SetBodyHandler(handle func(body *ast.BlockStmt, kind int)) *CodeBuilder {
  2293:		if ini, ok := p.current.codeBlock.(interface {
  2294:			SetBodyHandler(func(body *ast.BlockStmt, kind int))
(dlv) p p
*github.com/goplus/gox.CodeBuilder {
	stk: github.com/goplus/gox/internal.Stack {
		data: []*github.com/goplus/gox/internal.Elem len: 0, cap: 64, [],},
	current: github.com/goplus/gox.funcBodyCtx {
		codeBlockCtx: (*"github.com/goplus/gox.codeBlockCtx")(0xc00011a2a8),
		fn: *github.com/goplus/gox.Func nil,
		labels: map[string]*github.com/goplus/gox.Label nil,},
	comments: *go/ast.CommentGroup nil,
	pkg: *github.com/goplus/gox.Package {
		PkgRef: (*"github.com/goplus/gox.PkgRef")(0xc00011a240),
		cb: (*"github.com/goplus/gox.CodeBuilder")(0xc00011a290),
		files: [2]github.com/goplus/gox.file [
			(*"github.com/goplus/gox.file")(0xc00011a350),
			(*"github.com/goplus/gox.file")(0xc00011a3b8),
		],
		conf: *(*"github.com/goplus/gox.Config")(0xc00013e0c0),
		modPath: "",
		Fset: *go/token.FileSet nil,
		builtin: *(*"go/types.Package")(0xc00005d540),
		utBigInt: *go/types.Named nil,
		utBigRat: *go/types.Named nil,
		utBigFlt: *go/types.Named nil,
		loadPkgs: github.com/goplus/gox.LoadGoPkgs,
		autoIdx: 0,
		testingFile: 0,
		commentedStmts: map[go/ast.Stmt]*go/ast.CommentGroup nil,},
	varDecl: *github.com/goplus/gox.ValueDecl nil,
	interp: github.com/goplus/gox.NodeInterpreter(github.com/goplus/gox.nodeInterp) {},
	loadNamed: github.com/goplus/gox.defaultLoadNamed,
	handleErr: github.com/goplus/gox.defaultHandleErr,
	closureParamInsts: github.com/goplus/gox.closureParamInsts {
		paramInsts: map[github.com/goplus/gox.closureParamInst]*go/types.Var [],},
	iotav: 0,
	commentOnce: false,}
```

**把 package 转成源代码**

即把 package 描述的代码，AST 语法树转成对应语言字符串代码

这个机制用到了 go/format， 但这个过程做了一些封装，添加了一些额外信息的处理输出，比如注释等

```go
=>  45:	func WriteTo(dst io.Writer, pkg *Package, testingFile bool) (err error) {
    46:		fset := token.NewFileSet()
    47:		return format.Node(dst, fset, CommentedASTFile(pkg, testingFile))
    48:	}
    49:
    50:	// WriteFile func
(dlv) bt
0  0x00000000013123aa in github.com/goplus/gox.WriteTo
   at ./github.com/goplus/gox/gow.go:45
1  0x0000000001331f18 in main.domTestEx
   at ./testpkg.go:79
2  0x0000000001331e4a in main.domTest
   at ./testpkg.go:74
```

**可以看到 AST 语法树的顶层节点入口  ast.File**

go/format 格式化输出代码，就是从 ast.File 开始的， 把 ast.File 中的语法声明形象都补全，就可以输出语法树对应的代码

```go
> github.com/goplus/gox.ASTFile() ./github.com/goplus/gox/gow.go:33 (PC: 0x131213f)
    28:	// ----------------------------------------------------------------------------
    29:
    30:	// ASTFile func
    31:	func ASTFile(pkg *Package, testingFile bool) *ast.File {
    32:		idx := getInTestingFile(testingFile)
=>  33:		return &ast.File{Name: ident(pkg.Types.Name()), Decls: pkg.files[idx].getDecls(pkg)}
    34:	}
```

```go
> github.com/goplus/gox.CommentedASTFile() ./github.com/goplus/gox/gow.go:38 (PC: 0x13122fe)
    33:		return &ast.File{Name: ident(pkg.Types.Name()), Decls: pkg.files[idx].getDecls(pkg)}
    34:	}
    35:
    36:	// CommentedASTFile func
    37:	func CommentedASTFile(pkg *Package, testingFile bool) *printer.CommentedNodes {
=>  38:		return &printer.CommentedNodes{
    39:			Node:           ASTFile(pkg, testingFile),
    40:			CommentedStmts: pkg.commentedStmts,
    41:		}
    42:	}
    43:
```

```go
> github.com/goplus/gox/internal/go/format.Node() ./github.com/goplus/gox/internal/go/format/format.go:57 (PC: 0x1251b7a)
    52:	// The function may return early (before the entire result is written)
    53:	// and return a formatting error, for instance due to an incorrect AST.
    54:	//
    55:	func Node(dst io.Writer, fset *token.FileSet, node interface{}) error {
    56:		// Determine if we have a complete source file (file != nil).
=>  57:		var file *ast.File
    58:		var cnode *printer.CommentedNode
    59:		switch n := node.(type) {
    60:		case *ast.File:
    61:			file = n
    62:		case *printer.CommentedNode:
(dlv) bt
0  0x0000000001251b7a in github.com/goplus/gox/internal/go/format.Node
   at ./github.com/goplus/gox/internal/go/format/format.go:57
1  0x000000000131241a in github.com/goplus/gox.WriteTo
   at ./github.com/goplus/gox/gow.go:47
```

**源代码对应的字节流**

把 AST 语法树生成对应的源代码字节流转成字符串

```go
=>  83:		result := b.String()
    84:		if result != expected {
    85:			//	t.Fatalf("\nResult:\n%s\nExpected:\n%s\n", result, expected)
    86:		}
    87:		log.Printf(result)
    88:		log.Printf("====================== %s End =========================\n")
(dlv) p b
bytes.Buffer {
	buf: []uint8 len: 76, cap: 154, [112,97,99,107,97,103,101,32,109,97,105,110,10,10,105,109,112,111,114,116,32,102,109,116,32,34,102,109,116,34,10,10,102,117,110,99,32,109,97,105,110,40,41,32,123,10,9,102,109,116,46,80,114,105,110,116,108,110,40,102,109,116,46,80,...+12 more],
	off: 0,
	lastRead: opInvalid (0),}
(dlv) n
> main.domTestEx() ./testpkg.go:84 (PC: 0x1331f44)
    79:		err := gox.WriteTo(&b, pkg, testingFile)
    80:		if err != nil {
    81:			//t.Fatal("gox.WriteTo failed:", err)
    82:		}
    83:		result := b.String()
=>  84:		if result != expected {
    85:			//	t.Fatalf("\nResult:\n%s\nExpected:\n%s\n", result, expected)
    86:		}
    87:		log.Printf(result)
    88:		log.Printf("====================== %s End =========================\n")
    89:	}
(dlv) p result
"package main\n\nimport fmt \"fmt\"\n\nfunc main() {\n\tfmt.Println(fmt.P...+12 more"
```
